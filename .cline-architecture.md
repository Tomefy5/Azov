# CLINE ARCHITECTURE PATTERNS FOR AZOV

## üéØ ARCHITECTURE LAYERS

```
Request ‚Üí Routes ‚Üí Controllers ‚Üí Services ‚Üí Repositories ‚Üí Database
                                    ‚Üì
                            Integrations (Walrus, Sui, etc)
```

---

## üìö BACKEND PATTERNS

### 1Ô∏è‚É£ SERVICE LAYER (Business Logic)

```
// ‚úÖ backend/src/services/identity.service.ts

import { PrismaClient } from '@prisma/client';
import { Logger } from '../lib/logger';
import { WalrusClient } from '../lib/walrus';
import { SuiClient } from '../lib/sui';
import { OllamaService } from './ollama.service';
import { VerifyIdentitySchema, VerifyIdentityInput } from '../types/identity';

export class IdentityService {
  constructor(
    private prisma: PrismaClient,
    private walrus: WalrusClient,
    private sui: SuiClient,
    private ollama: OllamaService,
    private logger: Logger
  ) {}

  /**
   * Verify user identity with document and biometric
   * @param input - Verification input with user ID and document
   * @returns Promise with certificate ID and verification status
   */
  async verifyIdentity(input: VerifyIdentityInput): Promise<{
    success: boolean;
    certificateId: string;
    score: number;
    message: string;
  }> {
    try {
      // 1. VALIDATE INPUT
      const validated = VerifyIdentitySchema.parse(input);
      this.logger.debug('Identity verification started', { userId: validated.userId });

      // 2. CHECK USER EXISTS
      const user = await this.getUserOrThrow(validated.userId);

      // 3. EXTRACT OCR FROM DOCUMENT
      const documentText = await this.ollama.extractText(
        validated.documentPath
      );
      if (!documentText) {
        throw new Error('Failed to extract document text');
      }

      // 4. VERIFY BIOMETRIC (Liveness + Face Recognition)
      const biometricScore = await this.verifyBiometric(
        validated.selfieImage
      );
      if (biometricScore < 80) {
        throw new Error('Biometric verification failed (score too low)');
      }

      // 5. STORE ON WALRUS (Encrypted)
      const walrusBlob = await this.walrus.store({
        data: {
          documentText,
          documentHash: this.hashData(documentText),
          biometricScore,
          timestamp: new Date().toISOString(),
        },
        encrypted: true,
        userKey: user.walletAddress,
      });
      this.logger.info('Data stored on Walrus', { blobId: walrusBlob.id });

      // 6. CREATE CERTIFICATE ON SUI BLOCKCHAIN
      const certificate = await this.sui.createCertificate({
        userId: user.id,
        walrusBlob: walrusBlob.id,
        contentHash: this.hashData(documentText),
        certificateType: 'identity',
      });
      this.logger.info('Certificate created on Sui', { txId: certificate.txId });

      // 7. STORE IN DATABASE
      await this.prisma.certificate.create({
        data: {
          userId: user.id,
          type: 'identity',
          contentHash: this.hashData(documentText),
          walrusBlob: walrusBlob.id,
          suiTransaction: certificate.txId,
          status: 'verified',
        },
      });

      // 8. UPDATE USER REPUTATION
      await this.updateUserReputation(user.id, 'identity_verified');

      this.logger.info('Identity verification successful', {
        userId: user.id,
        certificateId: certificate.id,
      });

      return {
        success: true,
        certificateId: certificate.id,
        score: biometricScore,
        message: 'Identity verified successfully',
      };
    } catch (error) {
      this.logger.error('Identity verification failed', error);
      throw this.handleError(error);
    }
  }

  // PRIVATE HELPER METHODS

  private async getUserOrThrow(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });
    if (!user) {
      throw new Error(`User not found: ${userId}`);
    }
    return user;
  }

  private async verifyBiometric(
    imageData: Buffer
  ): Promise<number> {
    try {
      const deepfakeResult = await this.ollama.detectDeepfake(imageData);
      if (deepfakeResult.isDeepfake) {
        throw new Error('Deepfake detected');
      }
      return deepfakeResult.confidenceScore;
    } catch (error) {
      this.logger.error('Biometric verification error', error);
      throw new Error('Failed to verify biometric');
    }
  }

  private hashData(data: string): string {
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(data).digest('hex');
  }

  private async updateUserReputation(userId: string, event: string) {
    const score = this.calculateReputationIncrease(event);
    await this.prisma.user.update({
      where: { id: userId },
      data: {
        reputationScore: {
          increment: score,
        },
      },
    });
  }

  private calculateReputationIncrease(event: string): number {
    const increases: Record<string, number> = {
      identity_verified: 25,
      employment_verified: 15,
      background_verified: 10,
    };
    return increases[event] || 0;
  }

  private handleError(error: Error) {
    if (error.message.includes('User not found')) {
      return new NotFoundError(error.message);
    }
    if (error.message.includes('Deepfake')) {
      return new ValidationError(error.message);
    }
    return new InternalError('Identity verification failed');
  }
}
```

---

### 2Ô∏è‚É£ CONTROLLER LAYER (HTTP Handling)

```
// ‚úÖ backend/src/controllers/identity.controller.ts

import { Request, Response } from 'express';
import { IdentityService } from '../services/identity.service';
import { Logger } from '../lib/logger';
import { UploadIdentitySchema } from '../types/identity';

export class IdentityController {
  constructor(
    private identityService: IdentityService,
    private logger: Logger
  ) {}

  /**
   * Handle identity upload request
   */
  async uploadIdentity(req: Request, res: Response): Promise<void> {
    try {
      // 1. VALIDATE REQUEST
      const validated = UploadIdentitySchema.parse(req.body);

      // 2. CALL SERVICE
      const result = await this.identityService.verifyIdentity(validated);

      // 3. RETURN SUCCESS
      this.logger.info('Identity upload successful', {
        userId: req.user?.id,
        certificateId: result.certificateId,
      });
      res.status(200).json({
        success: true,
        data: result,
      });
    } catch (error) {
      this.handleError(error, res);
    }
  }

  /**
   * Get user identity profile
   */
  async getIdentity(req: Request, res: Response): Promise<void> {
    try {
      const { userId } = req.params;

      const profile = await this.identityService.getProfile(userId);

      res.status(200).json({
        success: true,
        data: profile,
      });
    } catch (error) {
      this.handleError(error, res);
    }
  }

  // ERROR HANDLING
  private handleError(error: Error, res: Response): void {
    this.logger.error('Controller error', error);

    if (error.name === 'ValidationError') {
      res.status(400).json({
        success: false,
        error: error.message,
      });
    } else if (error.name === 'NotFoundError') {
      res.status(404).json({
        success: false,
        error: error.message,
      });
    } else if (error.name === 'UnauthorizedError') {
      res.status(401).json({
        success: false,
        error: 'Unauthorized',
      });
    } else {
      res.status(500).json({
        success: false,
        error: 'Internal server error',
      });
    }
  }
}
```

---

### 3Ô∏è‚É£ ROUTES LAYER

```
// ‚úÖ backend/src/routes/identity.ts

import { Router, Request, Response } from 'express';
import { IdentityController } from '../controllers/identity.controller';
import { authMiddleware } from '../middleware/auth';

const router = Router();
const controller = new IdentityController(identityService, logger);

// All routes require authentication
router.use(authMiddleware);

/**
 * POST /api/identity/upload
 * Upload and verify identity document
 */
router.post('/upload', (req: Request, res: Response) =>
  controller.uploadIdentity(req, res)
);

/**
 * GET /api/identity/:userId
 * Get user identity profile
 */
router.get('/:userId', (req: Request, res: Response) =>
  controller.getIdentity(req, res)
);

export default router;
```

---

### 4Ô∏è‚É£ REPOSITORY LAYER (Data Access)

```
// ‚úÖ backend/src/repositories/user.repository.ts

import { PrismaClient, User } from '@prisma/client';

export class UserRepository {
  constructor(private prisma: PrismaClient) {}

  async findById(userId: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { id: userId },
    });
  }

  async findByWallet(walletAddress: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { walletAddress },
    });
  }

  async findByPhone(phoneNumber: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { phoneNumber },
    });
  }

  async create(data: {
    phoneNumber: string;
    email?: string;
    walletAddress: string;
  }): Promise<User> {
    return this.prisma.user.create({
      data: {
        ...data,
        reputationScore: 50,
        trustLevel: 'New',
      },
    });
  }

  async update(
    userId: string,
    data: Partial<User>
  ): Promise<User> {
    return this.prisma.user.update({
      where: { id: userId },
      data,
    });
  }

  async incrementReputation(userId: string, points: number): Promise<User> {
    return this.prisma.user.update({
      where: { id: userId },
      data: {
        reputationScore: {
          increment: points,
        },
      },
    });
  }
}
```

---

## üé® FRONTEND PATTERNS

### 1Ô∏è‚É£ REACT COMPONENT PATTERN

```
// ‚úÖ frontend/src/components/IdentityForm.tsx

'use client';

import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { ErrorMessage } from './ui/error-message';
import { LoadingSpinner } from './ui/loading-spinner';
import { identityApi } from '@/services/identity';

// VALIDATION SCHEMA
const IdentityFormSchema = z.object({
  document: z
    .instanceof(File)
    .refine((file) => file.size < 5000000, 'File must be less than 5MB')
    .refine(
      (file) => ['application/pdf', 'image/jpeg', 'image/png'].includes(file.type),
      'Invalid file type'
    ),
  selfie: z
    .instanceof(File)
    .refine((file) => file.size < 2000000, 'File must be less than 2MB')
    .refine(
      (file) => ['image/jpeg', 'image/png'].includes(file.type),
      'Invalid image type'
    ),
});

type IdentityFormData = z.infer<typeof IdentityFormSchema>;

// COMPONENT PROPS
interface IdentityFormProps {
  userId: string;
  onSuccess?: (certificateId: string) => void;
  isLoading?: boolean;
}

// COMPONENT
export const IdentityForm: React.FC<IdentityFormProps> = ({
  userId,
  onSuccess,
  isLoading = false,
}) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<IdentityFormData>({
    resolver: zodResolver(IdentityFormSchema),
  });

  const onSubmit = async (data: IdentityFormData) => {
    try {
      setIsSubmitting(true);
      setError(null);

      // Upload files
      const result = await identityApi.verify(userId, {
        document: data.document,
        selfie: data.selfie,
      });

      setSuccess('Identity verified successfully!');
      onSuccess?.(result.certificateId);
      reset();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setError(message);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <div>
        <label htmlFor="document" className="block text-sm font-medium">
          Government ID
        </label>
        <input
          {...register('document')}
          type="file"
          accept=".pdf,.jpg,.jpeg,.png"
          className="mt-1 block w-full"
        />
        {errors.document && (
          <ErrorMessage message={errors.document.message} />
        )}
      </div>

      <div>
        <label htmlFor="selfie" className="block text-sm font-medium">
          Selfie Photo
        </label>
        <input
          {...register('selfie')}
          type="file"
          accept=".jpg,.jpeg,.png"
          className="mt-1 block w-full"
        />
        {errors.selfie && (
          <ErrorMessage message={errors.selfie.message} />
        )}
      </div>

      {error && <ErrorMessage message={error} />}
      {success && <SuccessMessage message={success} />}

      <Button
        type="submit"
        disabled={isLoading || isSubmitting}
        className="w-full"
      >
        {isSubmitting ? (
          <>
            <LoadingSpinner className="mr-2" />
            Verifying...
          </>
        ) : (
          'Verify Identity'
        )}
      </Button>
    </form>
  );
};
```

---

### 2Ô∏è‚É£ CUSTOM HOOK PATTERN

```
// ‚úÖ frontend/src/hooks/useIdentity.ts

import { useState, useCallback } from 'react';
import { identityApi } from '@/services/identity';

interface UseIdentityReturn {
  profile: IdentityProfile | null;
  loading: boolean;
  error: string | null;
  verify: (userId: string, data: VerifyData) => Promise<void>;
  fetchProfile: (userId: string) => Promise<void>;
}

export const useIdentity = (): UseIdentityReturn => {
  const [profile, setProfile] = useState<IdentityProfile | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchProfile = useCallback(async (userId: string) => {
    try {
      setLoading(true);
      setError(null);
      const data = await identityApi.getProfile(userId);
      setProfile(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch profile');
    } finally {
      setLoading(false);
    }
  }, []);

  const verify = useCallback(
    async (userId: string, data: VerifyData) => {
      try {
        setLoading(true);
        setError(null);
        await identityApi.verify(userId, data);
        await fetchProfile(userId);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Verification failed');
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [fetchProfile]
  );

  return { profile, loading, error, verify, fetchProfile };
};
```

---

### 3Ô∏è‚É£ ZUSTAND STORE PATTERN

```
// ‚úÖ frontend/src/stores/authStore.ts

import { create } from 'zustand';

interface AuthState {
  userId: string | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (userId: string, token: string) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>((set) => ({
  userId: null,
  token: null,
  isAuthenticated: false,

  login: (userId: string, token: string) =>
    set({
      userId,
      token,
      isAuthenticated: true,
    }),

  logout: () =>
    set({
      userId: null,
      token: null,
      isAuthenticated: false,
    }),
}));
```

---

## üîê VALIDATION PATTERN

```
// ‚úÖ Types with Zod schemas

import { z } from 'zod';

// SCHEMA
export const VerifyIdentitySchema = z.object({
  userId: z.string().uuid('Invalid user ID'),
  documentPath: z.string().min(1, 'Document path required'),
  selfieImage: z.instanceof(Buffer),
});

// TYPE
export type VerifyIdentityInput = z.infer<typeof VerifyIdentitySchema>;

// RESULT TYPE
export interface VerificationResult {
  success: boolean;
  certificateId: string;
  score: number;
  message: string;
}
```

---

## ‚ö†Ô∏è ERROR HANDLING PATTERN

```
// ‚úÖ Custom error classes

export class CustomError extends Error {
  constructor(
    public statusCode: number,
    message: string,
    public code?: string
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

export class ValidationError extends CustomError {
  constructor(message: string) {
    super(400, message, 'VALIDATION_ERROR');
  }
}

export class NotFoundError extends CustomError {
  constructor(message: string) {
    super(404, message, 'NOT_FOUND');
  }
}

export class UnauthorizedError extends CustomError {
  constructor(message: string = 'Unauthorized') {
    super(401, message, 'UNAUTHORIZED');
  }
}

export class InternalError extends CustomError {
  constructor(message: string) {
    super(500, message, 'INTERNAL_ERROR');
  }
}
```

---

## üîó API CLIENT PATTERN

```
// ‚úÖ frontend/src/services/identity.ts

import axios, { AxiosInstance } from 'axios';

class IdentityApi {
  private api: AxiosInstance;

  constructor() {
    this.api = axios.create({
      baseURL: process.env.NEXT_PUBLIC_API_URL,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Add token to requests
    this.api.interceptors.request.use((config) => {
      const token = localStorage.getItem('authToken');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
  }

  async verify(
    userId: string,
    data: VerifyData
  ): Promise<VerificationResult> {
    const formData = new FormData();
    formData.append('userId', userId);
    formData.append('document', data.document);
    formData.append('selfie', data.selfie);

    const { data: result } = await this.api.post(
      '/identity/upload',
      formData,
      {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      }
    );

    return result.data;
  }

  async getProfile(userId: string): Promise<IdentityProfile> {
    const { data } = await this.api.get(`/identity/${userId}`);
    return data.data;
  }
}

export const identityApi = new IdentityApi();
```

---

## üß™ TESTING PATTERN

```
// ‚úÖ Unit test example

import { IdentityService } from '../identity.service';

describe('IdentityService', () => {
  let service: IdentityService;

  beforeEach(() => {
    service = new IdentityService(
      mockPrisma,
      mockWalrus,
      mockSui,
      mockOllama,
      mockLogger
    );
  });

  describe('verifyIdentity', () => {
    it('should verify identity successfully', async () => {
      const result = await service.verifyIdentity(validInput);
      expect(result.success).toBe(true);
      expect(result.certificateId).toBeDefined();
    });

    it('should throw on invalid input', async () => {
      expect(() => service.verifyIdentity(invalidInput))
        .toThrow(ValidationError);
    });

    it('should handle biometric verification failure', async () => {
      mockOllama.detectDeepfake.mockResolvedValue({
        isDeepfake: true,
        confidenceScore: 0,
      });

      expect(() => service.verifyIdentity(input))
        .toThrow('Deepfake detected');
    });
  });
});
```

---

## üìã SUMMARY TABLE

| Layer | File | Purpose | Pattern |
|-------|------|---------|---------|
| **Service** | `*.service.ts` | Business logic | Inject dependencies, async methods |
| **Controller** | `*.controller.ts` | HTTP handling | Call service, handle errors |
| **Route** | `*.ts` | API endpoints | Express router, middleware |
| **Repository** | `*.repository.ts` | Data access | Prisma queries |
| **Component** | `*.tsx` | UI rendering | React hooks, Zod validation |
| **Hook** | `use*.ts` | Logic reuse | useState, useCallback |
| **Store** | `*Store.ts` | Global state | Zustand |
| **Service (API)** | `*.ts` | API client | Axios instance |

---

**Status**: Ready to use as reference üöÄ  
**Last Updated**: Nov 7, 2025

***

## üéØ COMMENT L'UTILISER

### 1Ô∏è‚É£ Cr√©er le fichier
```bash
cd azov-platform
# Copiez tout le contenu ci-dessus dans:
# .cline-architecture.md
```

### 2Ô∏è‚É£ R√©f√©rencer dans Cline
```
"Generate a new service following the pattern in .cline-architecture.md"
"Create a controller using the pattern from .cline-architecture.md"
"Build a React component following the template in .cline-architecture.md"
```

### 3Ô∏è‚É£ Cline va:
- ‚úÖ Utiliser les patterns montr√©s
- ‚úÖ G√©n√©rer du code coh√©rent
- ‚úÖ Respecter la structure
- ‚úÖ Ajouter les validations Zod
- ‚úÖ G√©rer les erreurs correctement

***

**Pr√™t!** Vous avez maintenant les 3 fichiers essentiels: `.cline-context.md`, `.cline-rules.md`, et `.cline-architecture.md` üéâ

